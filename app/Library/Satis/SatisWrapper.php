<?php

namespace App\Library\Satis;

use FS;
use Illuminate\Support\Collection;
use Log;
use Str;

/**
 * An opinionated wrapper around Satis with a simplified API
 */
class SatisWrapper
{
    const COMPOSER_HASHING_ALGORITHM = 'sha256';

    private string $outputPath;
    private string $composerHome;
    private string $satisConfigPath;
    private string $authPath;

    public function __construct()
    {
        $this->outputPath = config('app.satis.output_path');
        $this->composerHome = $this->outputPath . '/composer';
        $this->satisConfigPath = $this->composerHome . '/satis.json';
        $this->authPath = $this->composerHome . '/auth.json';

        FS::mkdir($this->outputPath);
    }

    /**
     * Take a large packages.json file generated by Satis and split it
     * into many smaller ones; then reference those smaller files from
     * the packages.json
     *
     * @param int $encodeOptions JSON encoding options
     */
    protected function splitPackagesJson(int $encodeOptions = 0): void
    {
        $outDir = $this->outputPath . '/splitted';

        $packagesData = FS::readJsonFile(
            $this->outputPath . '/packages.json',
            FS::PARSE_ASSOC,
        );

        $packages = [];
        foreach ($packagesData['includes'] as $includePath => $options) {
            $includeData = FS::readJsonFile(
                $this->outputPath . '/' . $includePath,
                FS::PARSE_ASSOC,
            );

            $packages = array_merge($packages, $includeData['packages']);
        }

        FS::remove($outDir);
        FS::mkdir($outDir);
        FS::mkdir($outDir . '/p');

        $providers = [];

        foreach ($packages as $packageName => $versions) {
            foreach ($versions as $version => &$data) {
                $data['uid'] = hexdec(
                    substr(md5($packageName . $version), 0, 10),
                );
            }

            $packageFileData = ['packages' => [$packageName => $versions]];
            $packageFileContent = json_encode(
                $packageFileData,
                $encodeOptions | JSON_UNESCAPED_SLASHES,
            );
            $packageContentHash = hash(
                static::COMPOSER_HASHING_ALGORITHM,
                $packageFileContent,
            );

            $providers[$packageName] = [
                static::COMPOSER_HASHING_ALGORITHM => $packageContentHash,
            ];
            $packageFilePath = sprintf(
                '%s$%s.json',
                $packageName,
                $packageContentHash,
            );

            $vendorDir = dirname($outDir . '/p/' . $packageFilePath);

            if (!FS::exists($vendorDir)) {
                FS::mkdir($vendorDir);
            }

            FS::dumpFile(
                $outDir . '/p/' . $packageFilePath,
                $packageFileContent,
            );
        }

        $providerFileData = ['providers' => $providers];
        $providerFileContent = json_encode(
            $providerFileData,
            $encodeOptions | JSON_UNESCAPED_SLASHES,
        );
        $providerContentHash = hash(
            static::COMPOSER_HASHING_ALGORITHM,
            $providerFileContent,
        );
        $providerFilePath = sprintf('provider$%s.json', $providerContentHash);

        FS::dumpFile($outDir . '/p/' . $providerFilePath, $providerFileContent);

        $packagesData = [
            'packages' => [],
            'search' => config('app.url') . '/search/%query%',
            'providers-url' => '/p/%package%$%hash%.json',
            'provider-includes' => [
                'p/provider$%hash%.json' => [
                    static::COMPOSER_HASHING_ALGORITHM => $providerContentHash,
                ],
            ],
        ];

        FS::dumpFile(
            $outDir . '/packages.json',
            json_encode($packagesData, $encodeOptions | JSON_UNESCAPED_SLASHES),
        );
    }

    /**
     * Add packages to the Composer repository
     * @param  array|Collection $collectionOrArray  The package-repository mapping to add
     * @return int                                  Result status code
     */
    public function batchAdd($collectionOrArray)
    {
        $array = collect($collectionOrArray)->toArray();

        foreach ($array as $package => $repo) {
            $package = full_package_name($package);

            Log::info('Add package', [
                'package' => $package,
                'repository' => $repo,
            ]);
        }

        $packageRepoMap = $this->readExistingPackages();

        foreach ($array as $package => $repo) {
            $packageRepoMap->set($package, $repo);
        }

        $this->prepareExecution($packageRepoMap);
        $command = $this->generateCommand($packageRepoMap->toPackagesArray());
        return $this->execute($command);
    }

    /**
     * Add a package to the Composer repository
     * @param string $package  The package to add
     * @param string $repo     The repository to map to the package
     */
    public function add($package, $repo)
    {
        $package = full_package_name($package);

        return $this->batchAdd([$package => $repo]);
    }

    /**
     * Remove a package by repo from the Composer repository
     * @param  string $package  The repository to remove
     * @return int|false        Result status code, `false` if repo does not exist
     */
    public function update($package)
    {
        $package = full_package_name($package);
        Log::info('Update package', ['package' => $package]);

        $map = $this->readExistingPackages();

        if ($map->containsPackage($package)) {
            $repoUrl = $map->getCorrespondingRepo($package);
            $command = $this->generateCommand(["--repository-url=$repoUrl"]);

            $this->prepareExecution($map);
            return $this->execute($command);
        } else {
            return false;
        }
    }

    /**
     * Update a package by repo
     *
     * @param string $repo    The repository identifier
     * @param string $user    The GitHub user owning the repository
     * @param string $vendor  The package vendor publishing the package
     * @return int|false The executed Satis command's exit code, `false` if the package does not exist
     */
    public function updateRepo($repo, $user, $vendor)
    {
        $packages = $this->readExistingPackages();

        if (!$packages->containsRepo($repo)) {
            $exitCode = $this->addRepo($repo, $user, $vendor);

            if ($exitCode !== 0) {
                return false;
            }

            $packages = $this->readExistingPackages();
        }

        if ($packages->containsRepo($repo)) {
            $package = $packages->getCorrespondingPackage($repo);

            Log::info('Update package', ['package' => $package]);

            $repoUrl = $packages->getCorrespondingRepo($package);
            $cmd = $this->generateCommand(["--repository-url=$repoUrl"]);
            return $this->execute($cmd);
        } else {
            return 0;
        }
    }

    /**
     * Add a package by repo to the Composer repository
     *
     * @param  string $repo    The repository to add
     * @param  string $user    The user of the repository to add
     * @param  string $vendor  The vendor of the package
     * @return int           Result status code
     */
    public function addRepo($repo, $user, $vendor)
    {
        try {
            $package = $this->scanRepo($repo, $user, $vendor);

            if (is_null($package)) {
                throw new \InvalidArgumentException(
                    sprintf('Repository %s does not contain a package', $repo),
                );
            }

            $packages = $this->readExistingPackages();

            $packages->set($package['name'], $repo);

            $this->prepareExecution($packages);
        } catch (\InvalidArgumentException $_e) {
            Log::notice('Repository does not contain a package', [
                'repository' => $repo,
            ]);

            return 1;
        }

        return 0;
    }

    /**
     * Remove a package by repo from the Composer repository
     *
     * @param  string $repo  The repository to remove
     * @return int|false     Result status code, `false` if package does not exist
     */
    public function removeRepo($repo)
    {
        $packages = $this->readExistingPackages();

        if ($packages->containsRepo($repo)) {
            $package = $packages->getCorrespondingPackage($repo);
            return $this->remove($package);
        } else {
            return false;
        }
    }

    /**
     * Remove a package by repo from the Composer repository
     * @param  string $package  The repository to remove
     * @return int|false        Result status code, `false` if repo does not exist
     */
    public function remove($package)
    {
        $package = full_package_name($package);

        Log::info('Remove package', [
            'package' => $package,
        ]);

        $packages = $this->readExistingPackages();
        $success = $packages->remove($package);

        if ($success) {
            // Prepare execution to update satis.json
            $this->prepareExecution($packages);

            // Handle Satis packages.json
            $packagesData = FS::readJsonFile(
                $this->outputPath . '/packages.json',
                FS::PARSE_ASSOC,
            );

            foreach ($packagesData['includes'] as $includePath => $options) {
                $includeData = FS::readJsonFile(
                    $this->outputPath . '/' . $includePath,
                );

                if (isset($includeData->packages->{$package})) {
                    unset($includeData->packages->{$package});
                }

                $includeJson =
                    json_encode(
                        $includeData,
                        JSON_UNESCAPED_SLASHES |
                            JSON_PRETTY_PRINT |
                            JSON_UNESCAPED_UNICODE,
                    ) . "\n";
                $includeHash = sha1($includeJson);

                $newIncludePath = sprintf('include/all$%s.json', $includeHash);

                FS::dumpFile(
                    sprintf('%s/%s', $this->outputPath, $newIncludePath),
                    $includeJson,
                );
                FS::remove(sprintf('%s/%s', $this->outputPath, $includePath));

                unset($packagesData['includes'][$includePath]);
                $packagesData['includes'][$newIncludePath] = [
                    'sha1' => $includeHash,
                ];
            }

            FS::dumpFile(
                sprintf('%s/%s', $this->outputPath, 'packages.json'),
                json_encode(
                    $packagesData,
                    JSON_UNESCAPED_SLASHES |
                        JSON_PRETTY_PRINT |
                        JSON_UNESCAPED_UNICODE,
                ) . "\n",
            );

            $this->splitPackagesJson();

            return 0;
        } else {
            return false;
        }
    }

    /**
     * Clear the existing Composer repository
     */
    public function clear()
    {
        Log::info('Clear package repository');

        $packages = $this->readExistingPackages();
        if ($packages->count()) {
            $this->prepareExecution(new PackageRepoMap());
            $cmd = $this->generateCommand();
            return $this->execute($cmd);
        } else {
            return 0;
        }
    }

    /**
     * Re-Build all packages from the existing satis.json
     */
    public function rebuild()
    {
        Log::info('Rebuild package repository');

        $packages = $this->readExistingPackages();
        if ($packages->count()) {
            $this->prepareExecution($packages);
            $cmd = $this->generateCommand();
            return $this->execute($cmd);
        } else {
            return 0;
        }
    }

    /**
     * Scans a certain GitHub repository for containment of a package
     */
    public function scanRepo($repo, $user, $vendor)
    {
        $shortRepo = PackageRepoMap::extractRepoIdentifier($repo);

        Log::info('Scan repository', ['repository' => $shortRepo]);

        $packageFinder = new RepoScanner([
            'github-user' => $user,
            'github-token' => config('app.repository.github_token'),
            'vendor' => $vendor,
        ]);

        $package = $packageFinder->containedPackage(
            PackageRepoMap::nameOnly($shortRepo),
        );

        if (
            $package &&
            isset($package['name']) &&
            substr($package['name'], 0, strlen($vendor) + 1) === $vendor . '/'
        ) {
            return $package;
        } else {
            return null;
        }
    }

    /**
     * Re-Scan all packages from the GitHub user
     *
     * @return integer The exit code of the command
     */
    public function rescan()
    {
        $packageFinder = new RepoScanner();

        Log::info('Re-scan package repository');

        $packages = $packageFinder->findAll();

        if ($packages->count()) {
            $this->prepareExecution($packages);
            $cmd = $this->generateCommand();
            return $this->execute($cmd);
        } else {
            return 0;
        }
    }

    /**
     * Generate the PHP command to achieve a certain Satis behaviour
     * The default Format is: [php-binary-path] [satis-binary-path] [sub-command] [satis-config-path] [output-path] [additional-args]
     * @param  array            $additionalArgs  Additional arguments to append to the command
     * @return string                            The resulting command
     */
    protected function generateCommand($additionalArgs = [])
    {
        // Assemble Satis command args
        $args = array_map('escapeshellarg', [
            // Set the timezone
            '-d',
            'date.timezone=' . config('app.timezone'),

            // Path to the satis executable
            base_path('vendor/bin/satis'),

            // We want the 'build' command
            'build',

            // The satis.json
            $this->satisConfigPath,

            // Where to put the output
            $this->outputPath,

            '--no-html-output',

            // Certain packages to check for
            ...$additionalArgs,
        ]);

        // Assemble the whole command
        return PHP_BINARY . ' ' . join(' ', $args) . ' 2>&1';
    }

    /**
     * Prepare the environment for the Satis command
     *
     * @param PackageRepoMap $packages The packages to be considered in the satis.json
     * @return void
     */
    protected function prepareExecution(PackageRepoMap $packages)
    {
        if (!FS::exists($this->composerHome)) {
            FS::mkdir($this->composerHome);
        }

        FS::dumpJsonFile($this->authPath, $this->generateAuthData());
        FS::dumpJsonFile(
            $this->satisConfigPath,
            $this->generateSatisConfig($packages),
        );
    }

    /**
     * Run a Satis command
     *
     * @param string $command The Satis command to execute
     * @return int The Satis command's exit code
     */
    protected function execute($command)
    {
        Log::info('Execute Satis command', ['command' => $command]);

        // Configure sub process
        $descriptor = [
            ['pipe', 'r'], // stdin
            ['pipe', 'w'], // stdout
            ['pipe', 'w'], // stderr
        ];

        // Start command
        $process = proc_open($command, $descriptor, $pipes, __DIR__, [
            'COMPOSER_HOME' => $this->composerHome,
        ]);

        // Pipe command's stdout to our stdout
        stream_copy_to_stream($pipes[1], STDOUT);

        // Close command's stdout
        fclose($pipes[1]);

        // Save command's stderr
        $stderr = stream_get_contents($pipes[2]);
        fclose($pipes[2]);

        // Close command's stdin
        fclose($pipes[0]);

        // Get exit code
        $exitCode = proc_get_status($process)['exitcode'];

        // If we got an error, show it
        if ($exitCode !== -1 && $exitCode !== 0) {
            Log::error('Failed to execute Satis command', [
                'stderr' => $stderr,
                'code' => $exitCode,
            ]);
        }

        // Close command's process
        proc_close($process);

        if ($exitCode !== -1) {
            $this->splitPackagesJson();
        }

        // For some reason, Satis returns -1 as non-error exit code, let's normalize this
        return $exitCode === -1 ? 0 : $exitCode;
    }

    /**
     * Reads existing packages from the satis.json
     * @return PackageRepoMap  The package/repo map of existing packages
     */
    public function readExistingPackages(): PackageRepoMap
    {
        if (!FS::exists($this->satisConfigPath)) {
            return new PackageRepoMap();
        } else {
            $data = FS::readJsonFile($this->satisConfigPath, FS::PARSE_ASSOC);
            $repoUrls = array_map(function ($repo) {
                return $repo['url'];
            }, $data['repositories']);

            $packageNames = sizeof($repoUrls)
                ? array_keys($data['require'])
                : [];

            return new PackageRepoMap(array_combine($packageNames, $repoUrls));
        }
    }

    /**
     * Generate HTTP Basic Auth data from a token for a Composer auth.json
     *
     * @return array
     */
    protected function generateAuthData()
    {
        return [
            'http-basic' => new \stdClass(),
            'github-oauth' => [
                'github.com' => config('app.repository.github_token'),
            ],
        ];
    }

    /**
     * Generate a Satis configuration
     *
     * @param PackageRepoMap $packages The packages to consider
     * @return array
     */
    protected function generateSatisConfig(PackageRepoMap $packages)
    {
        $repositories = $packages->generateSatisConfigRepositories();

        // We need 'require-all' if we got no repositories because
        // Satis cannot deal with an empty 'require' object
        $require = sizeof($repositories)
            ? ['require' => $packages->generateSatisConfigRequire()]
            : ['require-all' => true];

        return array_merge(
            [
                'name' => sprintf(
                    '%s/private-composer-repository-%s',
                    config('app.repository.package_vendor'),
                    Str::lower(Str::random()),
                ),
                'homepage' => config('app.url'),
                'repositories' => $repositories,
            ],
            $require,
        );
    }
}
